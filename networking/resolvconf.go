/*
Functions for setting up resolv.conf

https://go.dev/src/net/dnsconfig_unix.go

on initramfs systems /etc/resolv.conf is memory based. no need to safewrite/copy and fsync tricks

this is only way how resolv.conf is edited
*/
package networking

import (
	"fmt"
	"net"
	"net/netip"
	"os"
	"strings"
)

const RESOLVCONFFILE = "/etc/resolv.conf"

// Resolv.conf parsing.  Better than https://go.dev/src/net/dnsconfig.go  Only supported features
type ResolvConf struct {
	CommentTitle string       //One supported
	Nameserver   []netip.Addr // netip.IP is more modern, https://www.papercall.io/speakers/mdlayher/speaker_talks/222197-net-netip-introducing-go-s-new-ip-address-package
	Domain       string
	Search       string
	Unparsed     []string //Extra options etc... pack at end of file
}

// ReadResolvConf if file does not exist then return default resolv conf
func ReadResolvConf(fname string) (ResolvConf, error) {
	_, errExist := os.Stat(fname)
	if !os.IsExist(errExist) {
		return ResolvConf{CommentTitle: "generated by ctrlaltgo"}, nil
	}

	byt, errRead := os.ReadFile(fname)
	if errRead != nil {
		return ResolvConf{}, errRead
	}

	result := ResolvConf{}

	rows := strings.Split(string(byt), "\n")
	for rownumber, row := range rows {
		row = strings.TrimSpace(row)
		if len(row) == 0 {
			continue
		}
		if string(row[0]) == "#" {
			if len(result.CommentTitle) == 0 {
				result.CommentTitle = strings.Replace(row, "#", "", 1)
			} else {
				result.Unparsed = append(result.Unparsed, row)
			}
			continue
		}
		fie := strings.Fields(row)

		switch fie[0] {
		case "nameserver":
			if len(fie) < 2 {
				return result, fmt.Errorf("invalid row%v missing nameserver row:%s", row, rownumber)
			}
			namesrv, errParseNamesrv := netip.ParseAddr(fie[1])
			if errParseNamesrv != nil {
				return result, fmt.Errorf("error parsing row %v invalid ip address %s err:%s", rownumber, fie[1], errParseNamesrv)
			}
			result.Nameserver = append(result.Nameserver, namesrv)
		case "domain":
			if len(fie) < 2 {
				return result, fmt.Errorf("invalid row%v missing domain row:%s", row, rownumber)
			}
			result.Domain = fie[1]
		case "search":
		default:
			result.Unparsed = append(result.Unparsed, row) //Whole row as it is
		}
	}
	return result, nil
}

func (a ResolvConf) String() string {
	var sb strings.Builder
	if 0 < len(a.CommentTitle) {
		sb.WriteString("#" + a.CommentTitle + "\n")
	}

	if 0 < len(a.Domain) {
		sb.WriteString("domain " + a.Domain + "\n")
	}

	if 0 < len(a.Search) {
		sb.WriteString("search " + a.Search + "\n")
	}

	for _, ns := range a.Nameserver {
		sb.WriteString("nameserver " + ns.String() + "\n")
	}

	sb.WriteString(strings.Join(a.Unparsed, "\n"))
	sb.WriteString("\n")

	return sb.String()
}

func (a ResolvConf) Save(fname string) error {
	return os.WriteFile(fname, []byte(a.String()), 0666)
}

func convertNetIpArr(iplist []net.IP) ([]netip.Addr, error) {
	result := make([]netip.Addr, len(iplist))
	for i, ip := range iplist {
		item, errIntenal := netip.ParseAddr(ip.String())
		if errIntenal != nil {
			return result, fmt.Errorf("internal error when parsing %s  err:%s", ip.String(), errIntenal)
		}
		result[i] = item
	}
	return result, nil
}

// Set nameservers. Override and convert from old net.IP format
/*func (p *ResolvConf) SetNameservers(iplist []net.IP) error {
}*/
func (p *ResolvConf) haveNameserver(ip netip.Addr) bool {
	for _, a := range p.Nameserver {
		if a == ip {
			return true
		}
	}
	return false
}

// AddNameservers adds nameservers without duplicates
func (p *ResolvConf) AddNameservers(iplist []net.IP) error {
	lst, err := convertNetIpArr(iplist)
	if err != nil {
		return err
	}

	for _, item := range lst {
		if !p.haveNameserver(item) {
			p.Nameserver = append(p.Nameserver, item)
		}
	}
	return nil
}
